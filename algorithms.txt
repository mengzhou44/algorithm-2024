Sorting Algorithms

Merge Sort: A divide-and-conquer algorithm that splits the array into smaller subarrays, sorts them, and then merges them back together. Time complexity: O(n log n).

Quick Sort: Another divide-and-conquer algorithm that selects a "pivot" and partitions the array into elements less than or greater than the pivot. Time complexity: O(n log n) on average, O(n²) worst case (with poor pivot choices).

Heap Sort: Uses a binary heap data structure to sort an array. Time complexity: O(n log n).


Search Algorithms

Binary Search: The one you just learned! Efficiently finds a target in a sorted array. Time complexity: O(log n).

Breadth-First Search (BFS): A graph traversal algorithm that explores all nodes level by level, often used for shortest-path problems on unweighted graphs. Time complexity: O(V + E), where V is the number of vertices and E is the number of edges.

Depth-First Search (DFS): Another graph traversal algorithm that explores as far as possible along each branch before backtracking. Time complexity: O(V + E).


Dynamic Programming Algorithms

Fibonacci Sequence: A classical problem where you can use either recursion or dynamic programming (DP) to calculate Fibonacci numbers. DP optimizes the recursive approach by storing results to avoid repeated calculations. Time complexity: O(n).
Longest Common Subsequence (LCS): Given two sequences, this algorithm finds the length of their longest common subsequence. It’s solved using dynamic programming. Time complexity: O(m * n), where m and n are the lengths of the sequences.
Knapsack Problem: A famous DP problem where you need to maximize the value you can carry in a knapsack with a weight limit. Time complexity: O(n * W), where n is the number of items and W is the knapsack capacity.

Greedy Algorithms
Dijkstra’s Algorithm: Finds the shortest paths from a source node to all other nodes in a weighted graph with non-negative edges. Time complexity: O((V + E) log V).

Kruskal’s Algorithm: A minimum spanning tree (MST) algorithm for graphs, choosing the smallest edges and avoiding cycles. Time complexity: O(E log E).

Prim’s Algorithm: Another MST algorithm that builds the tree by adding the smallest edge that connects a new vertex. Time complexity: O(E log V).


Backtracking Algorithms
N-Queens Problem: Place N queens on an N×N chessboard so that no two queens threaten each other. This problem uses backtracking to find solutions.
Sudoku Solver: Given a partially filled 9×9 grid, fill it so that each column, row, and subgrid contains digits 1 through 9 exactly once.
Permutation Generator: Generate all permutations of a set of numbers or characters. Time complexity: O(n!).


Tree and Graph Algorithms
Inorder, Preorder, Postorder Traversals: These are ways of traversing binary trees. Time complexity: O(n), where n is the number of nodes.
Topological Sorting: Used in directed acyclic graphs (DAGs) to find an order of nodes that respect dependencies. Time complexity: O(V + E).
Union-Find (Disjoint Set): A data structure to keep track of elements that are partitioned into disjoint sets. It supports union and find operations. Often used in Kruskal's algorithm for finding minimum spanning trees. Time complexity: O(α(n)), where α(n) is the inverse Ackermann function.


String Matching Algorithms

Knuth-Morris-Pratt (KMP): An efficient string-searching algorithm that preprocesses the pattern to avoid redundant comparisons. Time complexity: O(m + n), where m is the pattern length and n is the text length.
Rabin-Karp Algorithm: Uses hashing to find any one of a set of pattern strings in a text. Time complexity: O(m + n) on average, O(mn) worst case.


**********************************************************
1. Array and String Problems
Two Sum: Find two numbers in an array that sum to a target value.
Longest Substring Without Repeating Characters: Given a string, find the length of the longest substring without repeating characters.
Maximum Subarray (Kadane's Algorithm): Find the contiguous subarray with the largest sum.
Rotate Array: Rotate an array to the right by a given number of steps.
Trapping Rain Water: Calculate how much water can be trapped after raining given an elevation map.


2. Sorting and Searching
Binary Search: Search for a target value in a sorted array.
Merge Intervals: Given a collection of intervals, merge overlapping ones.
Kth Largest Element in an Array: Find the Kth largest element in an unsorted array.
Search in Rotated Sorted Array: Search for a target value in a rotated sorted array.


3. Linked List Problems
Reverse a Linked List: Reverse the nodes in a linked list.
Detect Cycle in a Linked List (Floyd's Cycle Detection): Determine if a linked list has a cycle.
Merge Two Sorted Lists: Merge two sorted linked lists into one sorted list.
Remove Nth Node from End: Remove the Nth node from the end of a linked list.

4. Tree and Graph Problems
Binary Tree Inorder Traversal: Perform an inorder traversal of a binary tree.
Lowest Common Ancestor of a Binary Tree: Find the lowest common ancestor (LCA) of two given nodes in a binary tree.
Level Order Traversal (Breadth-First Search): Traverse a tree level by level.
Depth-First Search (DFS): Explore nodes of a graph/tree by diving deep into each branch.
Graph Cycle Detection: Detect cycles in an undirected or directed graph.

5. Dynamic Programming
Climbing Stairs: Find how many distinct ways there are to climb a staircase of n steps, where you can take 1 or 2 steps at a time.
Longest Increasing Subsequence: Find the length of the longest increasing subsequence in an array.
Knapsack Problem: Given weights and values, determine the maximum value you can obtain by filling a knapsack of a certain capacity.
Coin Change Problem: Find the fewest number of coins needed to make a certain amount.


6. Recursion and Backtracking
N-Queens Problem: Place N queens on an N×N chessboard such that no two queens threaten each other.
Permutations: Generate all permutations of a list or string.
Combinations: Generate all combinations of a list or array.
Word Search: Search for a word in a 2D grid of characters.

7. Math and Number Theory
Fibonacci Sequence: Generate the nth Fibonacci number.
Prime Numbers: Find all prime numbers up to a given number (Sieve of Eratosthenes).
Greatest Common Divisor (GCD): Find the GCD of two numbers (Euclidean algorithm).
Palindrome Number: Determine if a number is a palindrome.

8. Bit Manipulation
Single Number: In an array where every element appears twice except for one, find that single number.
Counting Bits: Count the number of 1s in the binary representation of a number.
Power of Two: Determine if a number is a power of two.

9. Stacks and Queues
Valid Parentheses: Determine if a string of parentheses is valid.
Min Stack: Design a stack that supports push, pop, and retrieving the minimum element in constant time.
Sliding Window Maximum: Given an array, find the maximum for each sliding window of size k.

10. Greedy Algorithms
Interval Scheduling Maximization: Find the maximum number of non-overlapping intervals.
Jump Game: Determine if you can reach the last index of an array, starting at the first index.
Meeting Rooms: Given meeting time intervals, determine if a person could attend all meetings.

11. Hashing and Hash Maps
Group Anagrams: Group strings that are anagrams of each other.
Top K Frequent Elements: Find the K most frequent elements in an array.
Longest Consecutive Sequence: Find the length of the longest consecutive elements sequence in an array.

12. Miscellaneous
LRU Cache: Design and implement a Least Recently Used (LRU) cache.
Median of Two Sorted Arrays: Find the median of two sorted arrays of different sizes.
Merge k Sorted Lists: Merge k sorted linked lists into one sorted linked list.
These problems cover a range of common data structures and algorithmic techniques
